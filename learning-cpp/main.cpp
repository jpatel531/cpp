//
//  main.cpp
//  learning-cpp
//
//  Created by Jamie Patel on 18/04/2015.
//  Copyright (c) 2015 Jamie Patel. All rights reserved.
//

#include <iostream>

using namespace std;

//int main(int argc, const char * argv[]) {
//    // insert code here...
//    cout << "Hello, World!\n";
//    return 0;
//}


// declaring variables

//int main(){
//    int a, b;
//    int result;
//    
//    a = 5;
//    b = 2;
//    a = a + 1;
//    
//    cout << a;
//    
//    result = a - b;
//    
//    cout << result;
//    
//    return 0;
//}

// variables can be initialized also with () constructor and {}

//int main(){
//    int a = 5;
//    int b(3);
//    int c{2};
//    int result;
//    
//    a = a + b;
//    result = a - c;
//    cout << result;
//    return 0;
//}


// type deduction

//int main(){
//    int foo = 0;
//    auto bar = foo;
//    
//    cout << bar;
//    return 0;
//}

#include <string>

//intro to strings

//int main(){
//    string mystring;
//    mystring = "This is a string";
//    
//    /* 
//     string mystring ("This is a string");
//     string mystring {"This is string"};
//     */
//    
//    
//    cout << mystring;
//    return 0;
//}

//int main(){
//    string mystring;
//    mystring = "This is the initial string content";
//    cout << mystring << endl;
//    mystring = "This is a different string content";
//    cout << mystring << endl; // endl ends the line by printing a new line and flushing the stream
//    return 0;
//}
//



//CONSTANTS

// with const

//int main(){
//    const double pi = 3.141592654;
//    const char newline = '\n';
//    
//    double r = 5.0;
//    double circle;
//    
//    circle = 2 * pi * r;
//    cout << circle;
//    cout << newline;
//}

// with define

//#define PI 3.141592654 // do not require semicolons at the end
//#define NEWLINE '\n'
//
//int main(){
//    double r = 5.0;
//    double circle;
//    
//    circle = 2 * PI * r;
//    cout << circle;
//    cout << NEWLINE;
//}

//typecasting

//int main(){
//    int i;
//    float f = 3.14;
//    i = (int) f; // casts into an int
//    cout << i;
//}

// sizeof

//int main (){
//    int x = sizeof(char);
//    cout << x;
//}

// Basic I/O

/*
 cin => std input stream
 cout => std output stream
 cerr => standard error
 clog => std logging
 */

//int main (){
//    int i;
//    cout << "Please enter an integer value: ";
//    cin >> i;
//    cout << "The value you entered is " << i;
//    cout << " and its double is " << i * 2 << ".\n";
//    return 0;
//}


// cin always consideres spaces (whitespaces, tabs, newline) to be terminating the value being extracted
// extracting a string always gets a single word
// getline gets an entire line

//int main(){
//    string mystr;
//    cout << "What's your name?";
//    getline(cin, mystr);
//    cout << "Hello " << mystr << ".\n";
//    cout << "What's your favourite team? ";
//    getline(cin, mystr);
//    cout << "I like " << mystr << " too!\n";
//    return 0;
//}

//stringstream standard headed that allows a string to be treated as a stream.
// useful for converting strings to numeric values and vice versa

//#include <sstream> 
//
//int main(){
//    string mystr;
//    float price=0;
//    int quantity=0;
//    
//    cout << "Enter price: ";
//    getline(cin, mystr);
//    stringstream(mystr) >> price;
//    
//    cout << "Enter quantity: ";
//    getline(cin, mystr);
//    
//    stringstream(mystr) >> quantity;
//    
//    cout << "Total price: " << price*quantity << endl;
//    
//    return 0;
//    
//}

//control flow

/*
 if (x > 0)
    cout << "x is positive";
 else if (x < 0)
    cout << "x is negative";
 else
    cout << "x is 0";
 
 if more than one line, use braces
 
 */


// range-based for loops

//int main(){
//    string str {"Hello!"};
//    
////    each char in string
//    for (char c: str){
//        cout << "[" << c << "]";
//    }
//    cout << '\n';
//}

// passing parameters to functions by reference:

//void duplicate(int& a, int&b, int&c){ // what is passed is not a copy.
//    a*=2;
//    b*=2;
//    c*=2;
//}
//
//int main(){
//    int x(1), y(3), z(7);
//    
//    duplicate(x, y, z);
//    cout << "x=" << x << " , y=" << y << " , z=" << z;
//    return 0;
//}

/*
 Preceding a function declaration with the inline specifier informs the compiler that inline expansion is preferred over the usual function call mechanism for a specific function. This does not change at all the behavior of a function, but is merely used to suggest the compiler that the code generated by the function body shall be inserted at each point the function is called, instead of being invoked with a regular function call.
*/
// const: guarantee that its reference parameters are not going to be modified by this function.
//inline string concatenate(const string& a, const string& b){
//    return a+b;
//}


// DEFAULT ARGUMENTS IN PARAMETERS

//int divide(int a, int b=2){
//    int r;
//    r = a/b;
//    return r;
//}
//
//int main(){
//    cout << divide(12) << endl;
//    cout << divide(20,4) << endl;
//    return 0;
//}

// declaring functions prototypes beforehand so that they can be used even though they come after

//void odd(int x);
//void even(int x);
//
//int main(){
//    int i;
//    do {
//        cout << "Please, enter number (0 to exit): ";
//        cin >> i;
//        odd(i);
//    }while(i!=0);
//    return 0;
//}
//
//void odd(int x){
//    if ((x%2)!= 0) cout << "It is odd.\n";
//    else even(x);
//}
//
//void even(int x){
//    cout << "It is even.\n";
//}

// OVERLOADED FUNCTIONS

//two functions can have the same name if their
// parameters and return types are different

//int operate(int a, int b){
//    return (a*b);
//}
//
//double operate(double a, double b){
//    return (a/b);
//}
//
//int main(){
//    int x=5, y=2;
//    double n=5.0,m=2.0;
//    cout << operate(x,y) << endl;
//    cout << operate(n, m) << endl;
//    return 0;
//}

/*
 if you have multiple functions with the same name
 and same function body. e.g. a + b - you can use
 function templates
 */

//template <class T> // T represents a generic type
//T sum (T a, T b) {
//    T result;
//    result = a + b;
//    return result;
//}
//
//int main(){
//    int i=5, j=6, k;
//    
//    double f=2.0, g=0.5, h;
//    
//    k = sum<int>(i,j); // T is now int
//    
//    h = sum<double>(f, g); // T is now double
//    // angle backets only really necessary when the types are ambiguous
//    // in this case they are unneccessary as the compiler can infer ints and doubles
//    // respectively
//    
//    cout << k << endl;
//    cout << h << endl;
//    return 0;
//}

// if template has multiple types just do <class Type1, classType2>
// and sum<Type1,Type2>(x, y)

// ---- NON TYPE TEMPLATE ARGUMENTS ---

//// template params can include instances of types
//
//template <class T, int N>
//T fixed_multiply(T val){
//    return val * N;
//}
//
//// the second template arg always needs to be a constant expression
//
//int main(){
//    cout << fixed_multiply<int, 2>(10) << endl;
//    cout << fixed_multiply<int, 3>(10) << endl;
//    return 0;
//}


// --- NAMESPACES ---

//avoids clashing n ting

namespace foo {
    int value() {return 5;}
}

namespace bar {
    const double pi = 3.1416;
    double value(){return 2*pi;}
}

int main(){
    cout << foo::value() << endl;
    cout << bar::value() << endl;
    cout << bar::pi << endl;
    return 0;
}















